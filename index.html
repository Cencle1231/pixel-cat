<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åƒç´ å­—ç¬¦ç£åŠ›ç‰¹æ•ˆ</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1e1e1e; /* èƒŒæ™¯è‰² */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

<script>
    let sourceImage;
    let pixelChars = []; 

    // --- ğŸ”§ é…ç½®åŒºåŸŸ ---
    // âš ï¸ è¯·ç¡®ä¿è¿™ä¸ªå›¾ç‰‡æ–‡ä»¶å’Œ html æ–‡ä»¶åœ¨åŒä¸€ä¸ªæ–‡ä»¶å¤¹é‡Œï¼
    let imageFileName = 'pixel_art.png'; 
    
    let gridSize = 15;                   // ç½‘æ ¼å¤§å°
    let targetString = "cyber chan";     // å¾ªç¯æ–‡å­—

    // --- åŠ¨åŠ›å­¦å‚æ•° ---
    let influenceRange = gridSize * 6;   // å½±å“èŒƒå›´
    let moveSpeed = 0.08;                // ç§»åŠ¨/å½’ä½é€Ÿåº¦ (è¶Šå°è¶Šæ…¢)
    let maxPullStrength = 0.7;           // æœ€å¤§å¸å¼•åŠ›
    let maxRotation = Math.PI / 12;      // æœ€å¤§æ—‹è½¬è§’åº¦
    // --------------------

    function preload() {
        sourceImage = loadImage(imageFileName);
    }

    function setup() {
        if (!sourceImage) {
            console.error("å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶åæˆ–æœåŠ¡å™¨ç¯å¢ƒ");
            return;
        }
        
        sourceImage.loadPixels();
        
        // å¢åŠ ç”»å¸ƒè¾¹è·ï¼Œé˜²æ­¢å­—é£å‡ºå»
        let padding = 50;
        let canvasWidth = sourceImage.width * gridSize + padding * 2;
        let canvasHeight = sourceImage.height * gridSize + padding * 2;
        
        // åˆ›å»ºç”»å¸ƒå¹¶å±…ä¸­
        let cnv = createCanvas(canvasWidth, canvasHeight);
        
        textSize(gridSize * 0.9);
        textAlign(CENTER, CENTER);
        textStyle(BOLD);
        noStroke();
        angleMode(RADIANS); 

        let charIndex = 0;
        let offsetX = padding;
        let offsetY = padding;

        for (let y = 0; y < sourceImage.height; y++) {
            for (let x = 0; x < sourceImage.width; x++) {
                let c = sourceImage.get(x, y);
                // è¿™é‡Œå‡è®¾æ˜¯PNGï¼Œåˆ¤æ–­é€æ˜åº¦
                // å¦‚æœæ˜¯JPGï¼Œè¯·æ”¹ç”¨: if (c[0] < 250 || c[1] < 250 || c[2] < 250)
                if (c[3] > 10) {
                    let posX = x * gridSize + gridSize / 2 + offsetX;
                    let posY = y * gridSize + gridSize / 2 + offsetY;
                    let charToShow = targetString.charAt(charIndex % targetString.length);
                    
                    pixelChars.push(new PixelChar(posX, posY, c, charToShow));
                    charIndex++;
                }
            }
        }
    }

    function draw() {
        background(30);
        for (let p of pixelChars) {
            p.update();
            p.display();
        }
    }

    // --- ç²’å­ç±» ---
    class PixelChar {
        constructor(x, y, col, char) {
            this.origX = x; 
            this.origY = y;
            this.curX = x;
            this.curY = y;
            this.angle = 0; 
            this.rotDirection = Math.random() > 0.5 ? 1 : -1;
            this.origColor = col;
            this.char = char;
            
            let r = red(col) + 120;
            let g = green(col) + 120;
            let b = blue(col) + 120;
            this.highlightColor = color(r, g, b); 
        }

        update() {
            let d = dist(mouseX, mouseY, this.origX, this.origY);
            
            let targetX = this.origX;
            let targetY = this.origY;
            let targetAngle = 0;

            if (d < influenceRange) {
                let forceFactor = map(d, 0, influenceRange, 1, 0);
                forceFactor = pow(forceFactor, 1.5); 

                let vX = mouseX - this.origX;
                let vY = mouseY - this.origY;
                
                targetX = this.origX + vX * forceFactor * maxPullStrength;
                targetY = this.origY + vY * forceFactor * maxPullStrength;
                targetAngle = maxRotation * forceFactor * this.rotDirection;
            }

            this.curX = lerp(this.curX, targetX, moveSpeed);
            this.curY = lerp(this.curY, targetY, moveSpeed);
            this.angle = lerp(this.angle, targetAngle, moveSpeed);
        }

        display() {
            let d = dist(mouseX, mouseY, this.curX, this.curY);

            if (d < influenceRange / 2.5) {
                fill(this.highlightColor);
                let sizeScale = map(constrain(d, 0, influenceRange/2), 0, influenceRange/2.5, 1.3, 1.0);
                textSize(gridSize * sizeScale);
            } else {
                fill(this.origColor);
                textSize(gridSize * 0.9);
            }

            push();
            translate(this.curX, this.curY);
            rotate(this.angle);
            text(this.char, 0, 0);
            pop();
        }
    }
</script>

</body>
</html>